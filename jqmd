#!/usr/bin/env bash

# LICENSE
# -------
#
# `jqmd` is copyright 2017 PJ Eby,
# and MIT-licensed as follows:
#
# Permission is hereby granted, free of
# charge, to any person obtaining a copy
# of this software and associated
# documentation files (the "Software"),
# to deal in the Software without
# restriction, including without
# limitation the rights to use, copy,
# modify, merge, publish, distribute,
# sublicense, and/or sell copies of the
# Software, and to permit persons to
# whom the Software is furnished to do
# so, subject to the following
# conditions:
#
# The above copyright notice and this
# permission notice shall be included in
# all copies or substantial portions of
# the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS",
# WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT OWNERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

set -euo pipefail

source "$(command -v mdsh)"

RUN_JQ() {
    local opt nargs cmd=(jq) files=() opts=("${JQOPTS[@]:1}" "$@")
    while (("${#opts[@]}")); do
        opt="${opts[0]}"
        case "$opt" in
        -{f,-fromfile})                     nargs=2 ; FILTER <"${opts[1]}" ;;
        -{L,-indent})                       nargs=2 ;;
        --{arg,arjgson,slurpfile,argfile})  nargs=3 ;;
        --)  break   ;; # rest of args are data files
        -*)  nargs=1 ;;
        *)   FILTER "$opt"; break ;; # jq program: data files follow
        esac
        cmd+=("${opts[@]:0:$nargs}")    # add $nargs args to cmd
        opts=("${opts[@]:$nargs}")      # shift $nargs args off opts
    done

    HAVE_FILTERS || FILTER .    # jq needs at least one filter expression
    for opt in imports defines filters; do
        [[ -f "$MDSH_TMP/$opt.jq" ]] && files+=("$MDSH_TMP/$opt.jq");
    done

    opts[0]=n/a; "${cmd[@]}" -f <(cat "${files[@]}") "${opts[@]:1}"
    CLEAR_FILTERS   # cleanup for any re-runs
}

export-dotenv() {
    local before="" after=""
    before="$(compgen -v)"; source "$@"; after="$(compgen -v)"
    after="$(echo "$after" | grep -vxF -f <(echo "$before"))" || true
    [[ -z "$after" ]] || export $after
}

yaml2json() {
    python -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)';
}


catarg() {
    if (($# > 3)); then
        mdsh-error "Too many arguments: ""${@:3}";
    fi
    if [[ -f "$1" ]]; then echo -n "$2" >>"$1"; fi
    if (($# > 2)); then echo  -n "$3" >>"$1"; else cat >>"$1"; fi
}

HAVE_FILTERS() { [[ -n "$MDSH_TMP" ]] && [[ -f "$MDSH_TMP/filters.jq" ]] ; }
CLEAR_FILTERS() { if HAVE_FILTERS; then rm "$MDSH_TMP/filters.jq"; fi ; }

JQOPTS=(jq)
JQ_OPTS() { JQOPTS+=("$@"); }

ARG()     { JQ_OPTS --arg     "$1" "${2-$(cat)}"; }
ARGJSON() { JQ_OPTS --argjson "$1" "${2-$(cat)}"; }

IMPORTS() { mdsh-create-tempdir; catarg "$MDSH_TMP/imports.jq" $'\n' "$@"; }
DEFINE()  { mdsh-create-tempdir; catarg "$MDSH_TMP/defines.jq" $'\n' "$@"; }
FILTER()  { mdsh-create-tempdir; catarg "$MDSH_TMP/filters.jq" '|'   "$@"; }

YAML()    { yaml2json | JSON; }
JSON()    { FILTER < <(echo -n "jqmd_data("; cat; echo ")"); }

mdsh-lang-jq()   { FILTER ; }
mdsh-lang-yml()  { YAML ; }
mdsh-lang-yaml() { YAML ; }
mdsh-lang-json() { JSON ; }

mdsh-include-jq()   { FILTER <"$1" ; }
mdsh-include-env()  { export-dotenv "$@" ; }
mdsh-include-yml()  { YAML <"$1" ; }
mdsh-include-yaml() { YAML <"$1" ; }
mdsh-include-json() { JSON <"$1" ; }

# check bash-source and run main only if directly executing
if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then
    mdsh-main "$@"
    exit $?
fi

