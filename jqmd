#!/usr/bin/env bash

# LICENSE
# -------
#
# `jqmd` is copyright 2017 PJ Eby,
# and MIT-licensed as follows:
#
# Permission is hereby granted, free of
# charge, to any person obtaining a copy
# of this software and associated
# documentation files (the "Software"),
# to deal in the Software without
# restriction, including without
# limitation the rights to use, copy,
# modify, merge, publish, distribute,
# sublicense, and/or sell copies of the
# Software, and to permit persons to
# whom the Software is furnished to do
# so, subject to the following
# conditions:
#
# The above copyright notice and this
# permission notice shall be included in
# all copies or substantial portions of
# the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS",
# WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT OWNERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

set -euo pipefail

source "$(command -v mdsh)"

RUN_JQ() {
    local opt nargs cmd=(jq) opts=("${JQOPTS[@]:1}" "$@")

    while (("${#opts[@]}")); do
        opt="${opts[0]}"
        case "$opt" in
        -{f,-fromfile})                     nargs=2 ; FILTER <"${opts[1]}" ;;
        -{L,-indent})                       nargs=2 ;;
        --{arg,arjgson,slurpfile,argfile})  nargs=3 ;;
        --)  break   ;; # rest of args are data files
        -*)  nargs=1 ;;
        *)   FILTER "$opt"; break ;; # jq program: data files follow
        esac
        cmd+=("${opts[@]:0:$nargs}")    # add $nargs args to cmd
        opts=("${opts[@]:$nargs}")      # shift $nargs args off opts
    done

    HAVE_FILTERS || FILTER .    # jq needs at least one filter expression

    opts[0]=n/a; "${cmd[@]}" -f <(
        printf "%s\n" "${jqmd_imports-}" "${jqmd_defines-}" "${jqmd_filters-}"
    ) "${opts[@]:1}"

    CLEAR_FILTERS   # cleanup for any re-runs
}

export-dotenv() {
    local before="" after=""
    before="$(compgen -v)"; source "$@"; after="$(compgen -v)"
    after="$(echo "$after" | grep -vxF -f <(echo "$before"))" || true
    [[ -z "$after" ]] || export $after
}

yaml2json() {
    python -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)';
}

HAVE_FILTERS() {
    [[ -n ${jqmd_filters-} ]]
}

CLEAR_FILTERS() {
    unset jqmd_filters
}

JQOPTS=(jq)

JQ_OPTS() { JQOPTS+=("$@"); }

ARG()     { JQ_OPTS --arg     "$1" "$2"; }
ARGJSON() { JQ_OPTS --argjson "$1" "$2"; }

jqmd_imports=
jqmd_filters=
jqmd_defines=

IMPORTS() { jqmd_imports+="${jqmd_imports:+$'\n'}$1"; }
DEFINE()  { jqmd_defines+="${jqmd_defines:+$'\n'}$1"; }
FILTER()  { jqmd_filters+="${jqmd_filters:+|}$1"; }

YAML()    { JSON "$(echo "$1" | yaml2json)"; }
JSON()    { FILTER "jqmd_data($1)"; }

mdsh-lang-jq()   { FILTER "$(cat)"; }
mdsh-lang-yml()  { YAML "$(cat)"; }
mdsh-lang-yaml() { YAML "$(cat)"; }
mdsh-lang-json() { JSON "$(cat)"; }


# check bash-source and run main only if directly executing

if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then
    mdsh-main "$@"
    if HAVE_FILTERS; then RUN_JQ; fi
    exit $?
fi


