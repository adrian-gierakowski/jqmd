#!/usr/bin/env bash

# ---
# This file was automatically generated from jqmd.md - DO NOT EDIT!
# ---

# Copyright (c) 2017 PJ Eby
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

mdsh_raw_bash_runtime+=($'#!/usr/bin/env bash"\n\n# --- BEGIN jqmd runtime ---\n')
mdsh_raw_bash_runtime+=($'jqmd_imports=\njqmd_filters=\njqmd_defines=\n\nHAVE_FILTERS() { [[ ${jqmd_filters-} ]]; }\nCLEAR_FILTERS() { unset jqmd_filters; }\n\nIMPORTS() { jqmd_imports+="${jqmd_imports:+$\'\\n\'}$1"; }\nDEFINE()  { jqmd_defines+="${jqmd_defines:+$\'\\n\'}$1"; }\nFILTER()  { jqmd_filters+="${jqmd_filters:+|}$1"; }\n')
mdsh_raw_bash_runtime+=($'JQOPTS=(jq)\nJQ_OPTS() { JQOPTS+=("$@"); }\nARG()     { JQ_OPTS --arg     "$1" "$2"; }\nARGJSON() { JQ_OPTS --argjson "$1" "$2"; }\n')
mdsh_raw_bash_runtime+=($'RUN_JQ() {\n    local opt nargs cmd=(jq) opts=("${JQOPTS[@]:1}" "$@")\n\n    while (("${#opts[@]}")); do\n        opt="${opts[0]}"\n        case "$opt" in\n        -{f,-fromfile})                     nargs=2 ; FILTER <"${opts[1]}" ;;\n        -{L,-indent})                       nargs=2 ;;\n        --{arg,arjgson,slurpfile,argfile})  nargs=3 ;;\n        --)  break   ;; # rest of args are data files\n        -*)  nargs=1 ;;\n        *)   FILTER "$opt"; break ;; # jq program: data files follow\n        esac\n        cmd+=("${opts[@]:0:$nargs}")    # add $nargs args to cmd\n        opts=("${opts[@]:$nargs}")      # shift $nargs args off opts\n    done\n\n    HAVE_FILTERS || FILTER .    # jq needs at least one filter expression\n\n    opts[0]=n/a; "${cmd[@]}" -f <(\n        printf "%s\\n" "${jqmd_imports-}" "${jqmd_defines-}" "${jqmd_filters-}"\n    ) "${opts[@]:1}"\n\n    CLEAR_FILTERS   # cleanup for any re-runs\n}\n')
mdsh_raw_bash_runtime+=($'YAML()    { JSON "$(echo "$1" | yaml2json -)"; }\nJSON()    { FILTER "jqmd_data($1)"; }\n\ncommand -v yaml2json >/dev/null || yaml2json() {\n    python -c \'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)\';\n}\n\n# --- END jqmd runtime ---\n')
# Language Support
mdsh-compile-jq()   { printf 'FILTER %q\n' "$1"; }
mdsh-compile-yml()  { printf 'JSON %q\n' "$(echo "$1" | yaml2json -))"; }
mdsh-compile-yaml() { printf 'JSON %q\n' "$(echo "$1" | yaml2json -))"; }
mdsh-compile-json() { printf 'JSON %q\n' "$1"; }
# Load the runtime so it's usable by mdsh
printf -v REPLY '%s\n' "${mdsh_raw_bash_runtime[@]}"; eval "$REPLY"

# Add runtime to the top of compiled scripts
printf -v REPLY 'mdsh:file-header() { echo -n %q; }' "$REPLY"; eval "$REPLY"

# Ensure scripts process any leftover filters at end
mdsh:file-footer() { echo 'if [[ $0 == $BASH_SOURCE ]] && HAVE_FILTERS; then RUN_JQ; fi'; }
set -euo pipefail  # Strict mode


# read line from variable named by $1, reply in variable named by $2 (or REPLY)
mdsh-read() {
    [[ ${!1} && ${!1} =~ ^([^$'\n']*)($'\n'|$) ]] || return 1
    printf -v "${2-REPLY}" %s "${BASH_REMATCH[1]}"
    printf -v "$1"         %s "${!1#"$BASH_REMATCH"}"
}
mdsh-parse() {
    local cmd=$1 lang block md=$2 ln
    while mdsh-read md ln; do
        case $ln in
        '```'*)
            lang=${ln#'```'}; block=
            while mdsh-read md ln && [[ $ln != '```' ]]; do block+=$ln$'\n'; done
            "$cmd" backquote-fenced "$lang" "$block"
            ;;
        '~~~'*)
            while mdsh-read md ln && [[ $ln != '~~~'* ]]; do :; done ;;
        esac
    done
}
mdsh-compile() (  # <-- force subshell to prevent escape of compile-time state
    (($#)) && [[ $1 != '-' ]] && exec <"$1"  # take a file or stdin
    REPLY=$(cat; echo -n _); mdsh-parse __COMPILE__ "${REPLY%_}"
)
__COMPILE__() {
    [[ $1 == backquote-fenced ]] || return 0  # only fenced code
    local lang="${2//[^_[:alnum:]]/_}"; # convert language to safe variable/function name

    if fn-exists mdsh-lang-$lang; then
        mdsh-rewrite mdsh-lang-$lang "{" "} <<'\`\`\`'"; printf '%s```\n' "$3"
    elif fn-exists mdsh-compile-$lang; then
        mdsh-compile-$lang "$3"
    else
        mdsh-misc "$2" "$3"
    fi

    if fn-exists mdsh-after-$lang; then
        mdsh-rewrite mdsh-after-$lang
    fi
}
# fn-exists: succeed if argument is a function
fn-exists() { declare -F -- "$1"; } >/dev/null
# Output body of func $1, optionally replacing the opening/closing { and } with $2 and $3
mdsh-rewrite() {
    declare -f $1 | sed -e '1d; 2s/^{ $/'"${2-"{"}"'/; $s/^}$/'"${3-"\}"}"'/'
}
mdsh-misc()          { mdsh-data "$@"; }    # Treat unknown languages as data
mdsh-compile-()      { :; }                 # Ignore language-less blocks
mdsh-compile-mdsh()  { eval "$1"; }         # Execute `mdsh` blocks in-line
mdsh-compile-shell() { printf '%s' "$1"; }  # Copy `shell` blocks to the output
mdsh-data() {
    printf "mdsh_raw_${1//[^_[:alnum:]]/_}+=(%q)\n" "$2"
}
mdsh-compile-shell_mdsh() {
    __COMPILE__ backquote-fenced mdsh "$1"
}
# Main program: check for arguments and run markdown script
mdsh-main() {
    (($#)) || mdsh-error "Usage: %s [ --compile | --eval ] markdownfile [args...]" "${0#*/}"
    case "$1" in
    --) mdsh-interpret "${@:2}" ;;
    -)  mdsh-interpret "$@" ;;
    -*) fn-exists "mdsh.$1" || mdsh-error "%s: unrecognized option: %s" "${0#*/}" "$1"
        "mdsh.$1" "${@:2}"
        ;;
    *)  mdsh-interpret "$@" ;;
    esac
}
# Run markdown file as main program, with $0 == $BASH_SOURCE == "" and
# MDSH_ZERO pointing to the original $0.

function mdsh-interpret() {
    printf -v cmd 'eval "$(%q --compile %q)"' "$0" "$1"
    MDSH_ZERO="$1" exec bash -c "$cmd" "" "${@:2}"
}
mdsh.--compile() {
    (($#)) || mdsh-error "Usage: %s --compile FILENAME..." "${0#*/}"
    ! fn-exists mdsh:file-header || mdsh:file-header
    for f; do MDSH_SOURCE=$f mdsh-compile "$f"; done
    ! fn-exists mdsh:file-footer || mdsh:file-footer
}

mdsh.-c() { mdsh.--compile "$@"; }
mdsh.--eval() {
    (($# == 1)) && [[ $1 != - ]] ||
        mdsh-error "Usage: %s --eval FILENAME" "${0#*/}"
    mdsh.--compile "$1"
    echo "__status=\$? eval 'return \$__status || exit \$__status' 2>/dev/null"
}

mdsh.-E() { mdsh.--eval "$@"; }
# mdsh-error: printf args to stderr and exit w/EX_USAGE (code 64)
mdsh-error() { printf "$1\n" "${@:2}" >&2; exit 64; }
mdsh.--help() {
    printf "Usage: %s [ --compile | --eval ] markdownfile [args...]\n" "${0#*/}"
    echo -e '
Run and/or compile code blocks from markdownfile(s) to bash.
Use a filename of `-` to run or compile from stdin.

Options:
  -h, --help                Show this help message and exit
  -c, --compile MDFILE...   Compile MDFILE(s) to bash and output on stdout.
  -E, --eval MDFILE         Compile one file w/a shelldown-support footer line\n'
}

mdsh.-h() { mdsh.--help "$@"; }
# run-markdown file args...
# Compile `file` and source the result, passing along any positional arguments
run-markdown() { source <(mdsh-compile <"$1") "${@:2}"; }
# --- BEGIN DEPRECATED CODE ---
markdown-to-shell() {
    local arg cmd="$1" any='[^'"'"']\{1,\}'; local lang="${2:-$any}"

    # Build up an "or" of languages, if more than one given
    if (($#>2)); then printf -v lang '\|%q' "${@:3}"; lang="$2$lang"; fi
    extract-markdown '\('"$lang"'\)' "$cmd"' <<'"'"'```'"' '\\2'" '```'
}
extract-markdown() { extract-between '^```'"$1"'$' '^```$' "${@:2}"; }
extract-between() { sed -ne '/'"$1"'/,/'"$2"'/ { s/\('"$1"'\)/'"${3-}"'/; s/'"$2"'/'"${4-}"'/; p;}'; }
# --- END DEPRECATED CODE ---

# --- All functions have been defined, main script starts here! ---

# check bash-source and run main only if directly executing
if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then mdsh-main "$@"; exit $?; fi
